rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /* ---------- Helpers ---------- */
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId;
    }

    // Membership checks (active users should have roster doc id == uid)
    function isClassMember(classId) {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/classes/$(classId)/roster/$(request.auth.uid));
    }

    function membershipDoc(classId) {
      return get(/databases/$(database)/documents/classes/$(classId)/roster/$(request.auth.uid));
    }

    function hasRole(classId, role) {
      return isClassMember(classId) &&
             membershipDoc(classId).data.role == role;
    }

    function isTA(classId) {
      return hasRole(classId, "ta");
    }

    function isStudent(classId) {
      return hasRole(classId, "student");
    }

    function isInstructorOfClass(classId) {
      // Either roster role == instructor
      return isClassMember(classId) && hasRole(classId, "instructor");
    }

    function isOwnerOfClass(classId) {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/classes/$(classId)) &&
             get(/databases/$(database)/documents/classes/$(classId)).data.ownerId == request.auth.uid;
    }

    function canEditClassResource(classId) {
      return isSignedIn() && (
        isInstructorOfClass(classId) || isTA(classId) || isOwnerOfClass(classId)
      );
    }

    function targetNotExists() {
      // It's required for querying non-existent docs, e.g. an empty collection
      return resource == null
    }

    function isValidUserProfile(data) {
      return data.uid is string && data.uid.size() <= 128 &&
             data.displayName is string && data.displayName.size() >= 1 && data.displayName.size() <= 100 &&
             data.email is string && data.email.size() <= 320 &&
             (data.photoURL == null || (data.photoURL is string && data.photoURL.size() <= 2048)) &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidClassDoc(data) {
      return data.id is string && data.id.size() >= 6 && data.id.size() <= 128 &&
             data.title is string && data.title.size() >= 1 && data.title.size() <= 200 &&
             data.code is string && data.code.size() >= 6 && data.code.size() <= 64 &&
             data.ownerId is string && data.ownerId.size() <= 128 &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidRosterEntry(data) {
      return (data.userId == null || (data.userId is string && data.userId.size() <= 128)) &&
             data.email is string && data.email.size() <= 320 &&
             data.role in ["student", "ta", "instructor"] &&
             data.status in ["invited", "active", "removed"] &&
             (data.joinedAt == null || data.joinedAt is number);
    }

    function isValidAssignment(data) {
      return data.id is string && data.id.size() >= 6 && data.id.size() <= 128 &&
             (data.classId == null || (data.classId is string && data.classId.size() <= 128)) &&
             data.title is string && data.title.size() >= 1 && data.title.size() <= 300 &&
             data.prompt is string && data.prompt.size() >= 1 && data.prompt.size() <= 50000 &&
             data.mode == "instant" &&
             data.startAt is number &&
             (data.dueAt == null || data.dueAt is number) &&
             data.allowLate is bool &&
             data.allowResubmit is bool &&
             data.createdBy is string && data.createdBy.size() <= 128 &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidSubmission(data) {
      return data.userId is string && data.userId.size() <= 128 &&
             data.state in ["in_progress", "submitted", "graded_complete"] &&
             data.startedAt is number &&
             (data.submittedAt == null || data.submittedAt is number) &&
             data.late is bool &&
             (data.scoreCompletion == null || data.scoreCompletion is number) &&
             (data.notes == null || (data.notes is string && data.notes.size() <= 10000));
    }

    function isValidConversation(data) {
      return data.id is string && data.id.size() <= 128 &&
             data.assignmentId is string && data.assignmentId.size() <= 128 &&
             data.userId is string && data.userId.size() <= 128 &&
             data.state in ["awaiting_idea", "adding_counterpoint", "awaiting_followup", "adding_final_summary", "closed"] &&
             data.lastActionAt is number &&
             data.createdAt is number && data.updatedAt is number &&
             data.turns is list && data.turns.size() <= 1000;
    }

    /* ---------- Users ---------- */
    match /users/{uid} {
      allow get: if isSignedIn() && (uid == request.auth.uid);
      allow list: if false; // users cannot list all users
      allow create: if isSignedIn() && (uid == request.auth.uid) &&
                       isValidUserProfile(request.resource.data);
      allow update: if isSignedIn() && (uid == request.auth.uid) &&
                       isValidUserProfile(request.resource.data);
      allow delete: if false; // keep profiles
    }

    /* ---------- Classes ---------- */
    match /classes/{classId} {
      allow get: if isSignedIn() && (
        targetNotExists() || // allow reading non-existent docs
        isClassMember(classId) ||
        // Instructors who own the class (defensive in case roster is missing)
        (resource.data.ownerId == request.auth.uid)
      );

      allow list: if isSignedIn() && (
        targetNotExists() || // allow listing empty collection
        isClassMember(classId) ||
        // Instructors who own the class (defensive in case roster is missing)
        (resource.data.ownerId == request.auth.uid)
      );

      allow create: if isSignedIn() && isValidClassDoc(request.resource.data);
      allow update: if isSignedIn() && (
        resource.data.ownerId == request.auth.uid || isInstructorOfClass(classId)
      ) && isValidClassDoc(request.resource.data);
      allow delete: if isSignedIn() && (
        resource.data.ownerId == request.auth.uid || isInstructorOfClass(classId)
      );
    }

    /* ---------- Class Roster ---------- */
    match /classes/{classId}/roster/{memberId} {
      // Members can read their own roster entry
      allow get: if isSignedIn() && (
        memberId == request.auth.uid ||
        isClassMember(classId)
      );

      // Members can list the entire roster if they are a member
      allow list: if isSignedIn() && isClassMember(classId);

      // Only instructor (or owner) can invite / change roles / remove
      allow create, update: if isSignedIn() && (
        // allow if the class doc is not exists (initial setup)
        !exists(/databases/$(database)/documents/classes/$(classId)) ||
        isInstructorOfClass(classId) ||
        isOwnerOfClass(classId)
      ) && isValidRosterEntry(request.resource.data);
      allow delete: if isSignedIn() && (
        isInstructorOfClass(classId) ||
        isOwnerOfClass(classId)
      );
    }

    /* ---------- Assignments (top-level) ---------- */
    match /assignments/{aid} {
      allow get: if isSignedIn() && (
        targetNotExists() || // allow reading non-existent docs
        // standalone: visible to creator (check createdBy first)
        ('createdBy' in resource.data && resource.data.createdBy == request.auth.uid && 
         (!('classId' in resource.data) || resource.data.classId == null)) ||
        // class-bound assignments: visible to class members
        ('classId' in resource.data && resource.data.classId != null && isClassMember(resource.data.classId))
      );

      allow list: if isSignedIn() && (
        targetNotExists() || // allow listing empty collection
        // standalone: visible to creator (check createdBy first)
        ('createdBy' in resource.data && resource.data.createdBy == request.auth.uid && 
         (!('classId' in resource.data) || resource.data.classId == null)) ||
        // class-bound assignments: visible to class members
        ('classId' in resource.data && resource.data.classId != null && isClassMember(resource.data.classId))
      );

      // Create/update by class instructors/TAs or assignment creator for standalone
      allow create: if isSignedIn() && (
        (request.resource.data.classId != null &&
           (canEditClassResource(request.resource.data.classId))) ||
        (request.resource.data.classId == null && request.resource.data.createdBy == request.auth.uid)
      ) && isValidAssignment(request.resource.data);

      allow update: if isSignedIn() && (
        (resource.data.classId != null &&
           (canEditClassResource(resource.data.classId))) ||
        (resource.data.classId == null && resource.data.createdBy == request.auth.uid)
      ) && isValidAssignment(request.resource.data);

      allow delete: if isSignedIn() && (
        (resource.data.classId != null &&
           (canEditClassResource(resource.data.classId))) ||
        (resource.data.classId == null && resource.data.createdBy == request.auth.uid)
      );

      /* ------ Submissions subcollection ------ */
      match /submissions/{userId} {
        // GET:
        // - The student may read their own submission
        // - Instructors/TAs of the class may read all
        allow get: if isSignedIn() && (
          userId == request.auth.uid ||
          (get(/databases/$(database)/documents/assignments/$(aid)).data.classId != null &&
           canEditClassResource(get(/databases/$(database)/documents/assignments/$(aid)).data.classId))
        );

        // LIST:
        // - Instructors/TAs can list all submissions
        // - Students cannot list (can only get their own)
        allow list: if isSignedIn() && (
          get(/databases/$(database)/documents/assignments/$(aid)).data.classId != null &&
          canEditClassResource(get(/databases/$(database)/documents/assignments/$(aid)).data.classId)
        );

        // CREATE by the student (their own doc id == uid)
        allow create: if isSignedIn() && 
          userId == request.auth.uid &&
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.state == "in_progress" &&
          isValidSubmission(request.resource.data);
        
        // UPDATE by the student or instructor/TA
        allow update: if isSignedIn() && isValidSubmission(request.resource.data) && (
          // Student can edit their own while in progress or submit
          (userId == request.auth.uid &&
           request.resource.data.userId == request.auth.uid &&
           (
             (resource.data.state == "in_progress" && 
              request.resource.data.state in ["in_progress", "submitted"]) ||
             (resource.data.state == "submitted" && 
              request.resource.data.state == "submitted")
           )) ||

          // Instructor/TA can grade (move to graded_complete, set notes/score)
          (get(/databases/$(database)/documents/assignments/$(aid)).data.classId != null &&
           canEditClassResource(get(/databases/$(database)/documents/assignments/$(aid)).data.classId))
        );

        // Prevent deletion by students; allow for instructors if you really need it
        allow delete: if isSignedIn() && (
          get(/databases/$(database)/documents/assignments/$(aid)).data.classId != null &&
          isInstructorOfClass(get(/databases/$(database)/documents/assignments/$(aid)).data.classId)
        );
      }
    }

    /* ---------- Conversations (top-level) ---------- */
    match /conversations/{cid} {
      // GET:
      // - Owner (student)
      // - Instructors/TAs of linked assignment class
      allow get: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        (
          // Safely read assignment to resolve class
          exists(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)) &&
          canEditClassResource(get(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)).data.classId)
        )
      );

      // LIST:
      // - Owner (student) can list their own conversations
      // - Instructors/TAs of linked assignment class can list
      allow list: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        (
          // Safely read assignment to resolve class
          exists(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)) &&
          canEditClassResource(get(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)).data.classId)
        )
      );

      // CREATE: student creates their own conversation only
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid &&
        isValidConversation(request.resource.data);

      // UPDATE:
      // - Student can append turns / move through allowed states
      // - Instructors/TAs can move to closed
      // - If the last turn's pendingStartAt is not null, updates are denied
      allow update: if isSignedIn() &&
        isValidConversation(request.resource.data) &&
        (
          // Disallow update if last turn's pendingStartAt is not null
          (resource.data.turns.size() == 0 || resource.data.turns[resource.data.turns.size() - 1].pendingStartAt == null)
        ) && (
          request.auth.uid == resource.data.userId ||
          (
            exists(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)) &&
            canEditClassResource(get(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)).data.classId)
          )
        );

      // DELETE: typically disallow
      allow delete: if false;
    }

    /* ---------- Collection Group Rules ---------- */
    
    // Roster collection group - allows users to query their own roster entries across all classes
    match /{path=**}/roster/{memberId} {
      // Users can only query their own roster entries across all classes
      // This supports listMyEnrolledClasses API which queries: 
      // collectionGroup("roster").where("userId", "==", currentUser.uid).where("status", "==", "active")
      allow read: if isSignedIn() && 
        resource.data.userId == request.auth.uid;
    }

    /* ---------- Fallback ---------- */
    match /{document=**} {
      // Fallback deny
      allow get, list: if false;
      allow create, update, delete: if false;
    }
  }
}
