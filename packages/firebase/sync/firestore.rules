rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /* ---------- Helpers ---------- */
    function isSignedIn() {
      return request.auth != null;
    }

    // Membership checks require active roster status.
    function membershipDoc(courseId) {
      return get(/databases/$(database)/documents/courses/$(courseId)/roster/$(request.auth.uid));
    }

    function isCourseMember(courseId) {
      return isSignedIn() &&
             exists(/databases/$(database)/documents/courses/$(courseId)/roster/$(request.auth.uid)) &&
             membershipDoc(courseId).data.status == "active";
    }

    function hasRole(courseId, role) {
      return isCourseMember(courseId) &&
             membershipDoc(courseId).data.role == role;
    }

    function isTA(courseId) {
      return hasRole(courseId, "ta");
    }

    function isInstructorOfCourse(courseId) {
      // hasRole already checks isCourseMember internally
      return hasRole(courseId, "instructor");
    }

    function isOwnerOfCourse(courseId) {
      // Check if course exists first, then check ownership
      return isSignedIn() && 
        exists(/databases/$(database)/documents/courses/$(courseId)) &&
        get(/databases/$(database)/documents/courses/$(courseId)).data.ownerId == request.auth.uid;
    }

    function isPublicCourse(courseId) {
      return exists(/databases/$(database)/documents/courses/$(courseId)) &&
        get(/databases/$(database)/documents/courses/$(courseId)).data.visibility == "public";
    }

    function canEditCourseResource(courseId) {
      // Check owner first (simplest check), then fall back to role-based checks
      return isSignedIn() && (
        isOwnerOfCourse(courseId) || isInstructorOfCourse(courseId) || isTA(courseId)
      );
    }

    function targetNotExists() {
      // It's required for querying non-existent docs, e.g. an empty collection
      return resource == null || resource.data == null;
    }

    function isValidUserProfile(data) {
      return data.uid is string && data.uid.size() <= 128 &&
             (!('activeMode' in data) || data.activeMode in ["mentor", "student"]) &&
             data.displayName is string && data.displayName.size() >= 1 && data.displayName.size() <= 100 &&
             data.email is string && data.email.size() <= 320 &&
             (data.photoURL == null || (data.photoURL is string && data.photoURL.size() <= 2048)) &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidCourseAnnouncement(item) {
      return item is map &&
             'id' in item && item.id is string && item.id.size() >= 1 && item.id.size() <= 256 &&
             'content' in item && item.content is string && item.content.size() <= 2000 &&
             'createdAt' in item && item.createdAt is number &&
             'updatedAt' in item && item.updatedAt is number;
    }

    function isValidCourseAnnouncements(items) {
      return items is list &&
             items.size() <= 200 &&
             (items.size() == 0 ||
               (isValidCourseAnnouncement(items[0]) &&
                (items.size() == 1 || isValidCourseAnnouncement(items[items.size() - 1]))));
    }

    function isValidCourseDoc(data) {
      return data.title is string && data.title.size() >= 1 && data.title.size() <= 200 &&
             data.code is string && data.code.size() >= 6 && data.code.size() <= 64 &&
             data.ownerId is string && data.ownerId.size() <= 128 &&
             (!('visibility' in data) || data.visibility in ["public", "unlisted", "private"]) &&
             (!('passwordHash' in data) || data.passwordHash == null || (data.passwordHash is string && data.passwordHash.size() <= 512)) &&
             (!('theme' in data) || data.theme == null || (data.theme is string && data.theme.size() <= 200)) &&
             (!('description' in data) || data.description == null || (data.description is string && data.description.size() <= 5000)) &&
             (!('thumbnail' in data) || data.thumbnail == null ||
               (data.thumbnail is map &&
                'storagePath' in data.thumbnail && data.thumbnail.storagePath is string && data.thumbnail.storagePath.size() <= 1024 &&
                (!('url' in data.thumbnail) || data.thumbnail.url == null || (data.thumbnail.url is string && data.thumbnail.url.size() <= 2048))
               )
             ) &&
             (!('isDemo' in data) || data.isDemo is bool) &&
             (!('demoPolicy' in data) || data.demoPolicy == null ||
               (data.demoPolicy is map &&
                'maxFreeCreditsPerUser' in data.demoPolicy && data.demoPolicy.maxFreeCreditsPerUser is number && data.demoPolicy.maxFreeCreditsPerUser >= 0 &&
                (!('maxTurnsPerConversation' in data.demoPolicy) || data.demoPolicy.maxTurnsPerConversation == null || (data.demoPolicy.maxTurnsPerConversation is number && data.demoPolicy.maxTurnsPerConversation > 0))
               )
             ) &&
             (!('announcements' in data) || isValidCourseAnnouncements(data.announcements)) &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidRosterEntry(data) {
      return (data.userId == null || (data.userId is string && data.userId.size() <= 128)) &&
             data.email is string && data.email.size() <= 320 &&
             data.role in ["student", "auditor", "ta", "instructor"] &&
             data.status in ["invited", "active", "removed"] &&
             (data.joinedAt == null || data.joinedAt is number) &&
             (!('invitedAt' in data) || data.invitedAt == null || data.invitedAt is number);
    }

    function isValidAssignment(data) {
      return data.id is string && data.id.size() >= 6 && data.id.size() <= 128 &&
             (data.courseId == null || (data.courseId is string && data.courseId.size() <= 128)) &&
             (!('topicId' in data) || data.topicId == null || (data.topicId is string && data.topicId.size() <= 128)) &&
             data.title is string && data.title.size() >= 1 && data.title.size() <= 300 &&
             data.prompt is string && data.prompt.size() >= 1 && data.prompt.size() <= 50000 &&
             (!('question' in data) || data.question == null || (data.question is string && data.question.size() <= 2000)) &&
             data.mode == "instant" &&
             data.startAt is number &&
             (data.dueAt == null || data.dueAt is number) &&
             data.allowLate is bool &&
             data.allowResubmit is bool &&
             data.createdBy is string && data.createdBy.size() <= 128 &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidTopic(data) {
      return data.id is string && data.id.size() >= 6 && data.id.size() <= 128 &&
             data.courseId is string && data.courseId.size() <= 128 &&
             data.title is string && data.title.size() >= 1 && data.title.size() <= 200 &&
             (!('description' in data) || data.description == null || (data.description is string && data.description.size() <= 2000)) &&
             (!('order' in data) || data.order == null || (data.order is number)) &&
             data.contents is list && data.contents.size() <= 200 &&
             (data.contents.size() == 0 ||
               ((data.contents[0] is string && data.contents[0].size() >= 1 && data.contents[0].size() <= 500) &&
                (data.contents.size() == 1 ||
                  (data.contents[data.contents.size() - 1] is string &&
                   data.contents[data.contents.size() - 1].size() >= 1 &&
                   data.contents[data.contents.size() - 1].size() <= 500)))) &&
             data.contentTypes is list &&
             data.contentTypes.size() == data.contents.size() &&
             data.contentTypes.hasOnly(["assignment", "questionnaire"]) &&
             data.createdBy is string && data.createdBy.size() <= 128 &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidSubmission(data) {
      return data.userId is string && data.userId.size() <= 128 &&
             data.state in ["in_progress", "submitted", "graded_complete"] &&
             data.startedAt is number &&
             (data.submittedAt == null || data.submittedAt is number) &&
             data.late is bool &&
             (data.scoreCompletion == null || data.scoreCompletion is number) &&
             (data.notes == null || (data.notes is string && data.notes.size() <= 10000));
    }

    function isValidTokenUsageTotals(data) {
      return data is map &&
             (!('cachedContentTokenCount' in data) || (data.cachedContentTokenCount is number && data.cachedContentTokenCount >= 0)) &&
             (!('promptTokenCount' in data) || (data.promptTokenCount is number && data.promptTokenCount >= 0)) &&
             (!('toolUsePromptTokenCount' in data) || (data.toolUsePromptTokenCount is number && data.toolUsePromptTokenCount >= 0)) &&
             (!('thoughtsTokenCount' in data) || (data.thoughtsTokenCount is number && data.thoughtsTokenCount >= 0)) &&
             (!('candidatesTokenCount' in data) || (data.candidatesTokenCount is number && data.candidatesTokenCount >= 0)) &&
             (!('inputTokenCount' in data) || (data.inputTokenCount is number && data.inputTokenCount >= 0)) &&
             (!('outputTokenCount' in data) || (data.outputTokenCount is number && data.outputTokenCount >= 0)) &&
             (!('totalTokenCount' in data) || (data.totalTokenCount is number && data.totalTokenCount >= 0));
    }

    function isValidTokenUsageBreakdown(data) {
      return data is map &&
             (!('byFeature' in data) || data.byFeature is map) &&
             'totals' in data &&
             isValidTokenUsageTotals(data.totals);
    }

    function isValidConversationTurn(turn) {
      return turn is map &&
             'id' in turn && turn.id is string && turn.id.size() <= 128 &&
             'type' in turn && turn.type is string && turn.type.size() >= 1 && turn.type.size() <= 128 &&
             'text' in turn && turn.text is string && turn.text.size() >= 1 && turn.text.size() <= 20000 &&
             (!('analysis' in turn) ||
               turn.analysis == null ||
               (turn.analysis is map &&
                (!('stance' in turn.analysis) ||
                  (turn.analysis.stance is string && turn.analysis.stance.size() >= 1 && turn.analysis.stance.size() <= 32)))) &&
             (!('pendingStartAt' in turn) || turn.pendingStartAt == null || turn.pendingStartAt is number) &&
             (!('tokenUsage' in turn) || turn.tokenUsage == null || isValidTokenUsageBreakdown(turn.tokenUsage)) &&
             'createdAt' in turn && turn.createdAt is number;
    }

    function isValidConversationTokenUsage(data) {
      return data is map &&
             (!('byFeature' in data) || data.byFeature is map) &&
             'totals' in data &&
             isValidTokenUsageTotals(data.totals) &&
             'updatedAt' in data &&
             data.updatedAt is number;
    }

    function isValidConversation(data) {
      return data.assignmentId is string && data.assignmentId.size() <= 128 &&
             data.userId is string && data.userId.size() <= 128 &&
             data.state in ["awaiting_idea", "adding_counterpoint", "awaiting_followup", "adding_final_summary", "closed"] &&
             data.lastActionAt is number &&
             data.createdAt is number && data.updatedAt is number &&
             data.turns is list && data.turns.size() <= 1000 &&
             (data.turns.size() == 0 ||
               (isValidConversationTurn(data.turns[0]) &&
                (data.turns.size() == 1 || isValidConversationTurn(data.turns[data.turns.size() - 1])))) &&
             (!('tokenUsage' in data) || data.tokenUsage == null || isValidConversationTokenUsage(data.tokenUsage));
    }

    function isValidQuestionOptions(options) {
      return options is list &&
             options.size() >= 1 &&
             options.size() <= 100 &&
             (options[0] is string && options[0].size() >= 1 && options[0].size() <= 500) &&
             (options.size() == 1 ||
               (options[options.size() - 1] is string &&
                options[options.size() - 1].size() >= 1 &&
                options[options.size() - 1].size() <= 500));
    }

    function isValidQuestionDefinition(question) {
      return question is map &&
             'type' in question &&
             question.type in ["single_answer_choice", "multiple_answer_choice", "short_answer", "slider_answer"] &&
             'questionText' in question &&
             question.questionText is string &&
             question.questionText.size() >= 1 &&
             question.questionText.size() <= 5000 &&
             (
               ((question.type == "single_answer_choice" || question.type == "multiple_answer_choice") &&
                'options' in question &&
                isValidQuestionOptions(question.options)) ||
               (question.type == "short_answer") ||
               (question.type == "slider_answer" &&
                'minLabel' in question && question.minLabel is string && question.minLabel.size() >= 1 && question.minLabel.size() <= 100 &&
                'maxLabel' in question && question.maxLabel is string && question.maxLabel.size() >= 1 && question.maxLabel.size() <= 100 &&
                'minValue' in question && question.minValue is number &&
                'maxValue' in question && question.maxValue is number &&
                question.maxValue >= question.minValue &&
                'step' in question && question.step is number && question.step > 0)
             );
    }

    function isValidQuestionnaireQuestion(item) {
      return item is map &&
             'question' in item &&
             isValidQuestionDefinition(item.question) &&
             'required' in item &&
             item.required is bool;
    }

    function isValidQuestionnaire(data) {
      return data.id is string && data.id.size() >= 6 && data.id.size() <= 128 &&
             (data.courseId == null || (data.courseId is string && data.courseId.size() <= 128)) &&
             (!('topicId' in data) || data.topicId == null || (data.topicId is string && data.topicId.size() <= 128)) &&
             data.title is string && data.title.size() >= 1 && data.title.size() <= 300 &&
             data.questions is list && data.questions.size() >= 1 && data.questions.size() <= 100 &&
             isValidQuestionnaireQuestion(data.questions[0]) &&
             (data.questions.size() == 1 || isValidQuestionnaireQuestion(data.questions[data.questions.size() - 1])) &&
             data.startAt is number &&
             (data.dueAt == null || data.dueAt is number) &&
             data.allowLate is bool &&
             data.allowResubmit is bool &&
             data.createdBy is string && data.createdBy.size() <= 128 &&
             data.createdAt is number && data.updatedAt is number;
    }

    function isValidStringAnswerList(value, maxLength) {
      return value is list &&
             value.size() >= 1 &&
             value.size() <= 100 &&
             (value[0] is string && value[0].size() >= 1 && value[0].size() <= maxLength) &&
             (value.size() == 1 ||
               (value[value.size() - 1] is string &&
                value[value.size() - 1].size() >= 1 &&
                value[value.size() - 1].size() <= maxLength));
    }

    function isValidTypedAnswer(answer) {
      return answer is map &&
             'type' in answer &&
             answer.type in ["single_answer_choice", "multiple_answer_choice", "short_answer", "slider_answer"] &&
             'response' in answer &&
             (
               (answer.type == "single_answer_choice" &&
                answer.response is string &&
                answer.response.size() >= 1 &&
                answer.response.size() <= 500) ||
               (answer.type == "multiple_answer_choice" &&
                isValidStringAnswerList(answer.response, 500)) ||
               (answer.type == "short_answer" &&
                answer.response is string &&
                answer.response.size() >= 1 &&
                answer.response.size() <= 5000) ||
               (answer.type == "slider_answer" &&
                answer.response is number)
             );
    }

    // Validate a single questionnaire response item
    function isValidQuestionnaireResponseItem(item) {
      return item is map &&
             ('questionIndex' in item) &&
             (item.questionIndex is number) &&
             item.questionIndex >= 0 &&
             item.questionIndex <= 1000 &&
             ('answer' in item) &&
             isValidTypedAnswer(item.answer);
    }



    function isValidQuestionnaireResponse(data) {
      return data.questionnaireId is string && data.questionnaireId.size() <= 128 &&
             data.userId is string && data.userId.size() <= 128 &&
             (data.courseId == null || (data.courseId is string && data.courseId.size() <= 128)) &&
             data.responses is list && data.responses.size() >= 1 && data.responses.size() <= 100 &&
             isValidQuestionnaireResponseItem(data.responses[0]) &&
             (data.responses.size() == 1 || isValidQuestionnaireResponseItem(data.responses[data.responses.size() - 1])) &&
             data.submittedAt is number &&
             (!('updatedAt' in data) || data.updatedAt == null || data.updatedAt is number);
    }

    function assignmentDoc(assignmentId) {
      return get(/databases/$(database)/documents/assignments/$(assignmentId));
    }

    function questionnaireDoc(questionnaireId) {
      return get(/databases/$(database)/documents/questionnaires/$(questionnaireId));
    }

    /* ---------- Users ---------- */
    match /users/{uid} {
      allow get: if isSignedIn() && (uid == request.auth.uid);
      allow list: if false; // users cannot list all users
      allow create: if isSignedIn() && (uid == request.auth.uid) &&
                       isValidUserProfile(request.resource.data);
      allow update: if isSignedIn() && (uid == request.auth.uid) &&
                       isValidUserProfile(request.resource.data);
      allow delete: if false; // keep profiles
    }

    /* ---------- Courses ---------- */
    match /courses/{courseId} {
      // Public courses are readable by anyone; private/unlisted require membership or ownership
      allow get: if targetNotExists() ||
        (resource.data != null && 'visibility' in resource.data && resource.data.visibility == "public") ||
        (isSignedIn() && resource.data != null && 'ownerId' in resource.data && resource.data.ownerId == request.auth.uid) ||
        (isSignedIn() && resource.data != null && isCourseMember(courseId));

      // List: owner can list their courses, members can list courses they belong to, anyone can list public
      // Important: owner check must be evaluated separately to avoid type errors with isCourseMember in list queries
      allow list: if targetNotExists() ||
        (resource.data != null && 'visibility' in resource.data && resource.data.visibility == "public") ||
        (isSignedIn() && resource.data != null && 'ownerId' in resource.data && resource.data.ownerId == request.auth.uid) ||
        (isSignedIn() && resource.data != null && isCourseMember(courseId));

      allow create: if isSignedIn() && isValidCourseDoc(request.resource.data);
      allow update: if isSignedIn() && resource.data != null && (
        resource.data.ownerId == request.auth.uid || isInstructorOfCourse(courseId)
      ) && isValidCourseDoc(request.resource.data);
      allow delete: if isSignedIn() && resource.data != null && (
        resource.data.ownerId == request.auth.uid || isInstructorOfCourse(courseId)
      );
    }

    /* ---------- Topics ---------- */
    match /topics/{topicId} {
      allow get: if targetNotExists() ||
        (resource != null && resource.data != null && resource.data.courseId is string && isPublicCourse(resource.data.courseId)) ||
        (isSignedIn() && resource != null && resource.data != null && (isCourseMember(resource.data.courseId) || canEditCourseResource(resource.data.courseId)));

      allow list: if targetNotExists() ||
        (resource != null && resource.data != null && resource.data.courseId is string && isPublicCourse(resource.data.courseId)) ||
        (isSignedIn() && resource != null && resource.data != null && (isCourseMember(resource.data.courseId) || canEditCourseResource(resource.data.courseId)));

      allow create: if isSignedIn() &&
        canEditCourseResource(request.resource.data.courseId) &&
        isValidTopic(request.resource.data);

      allow update: if isSignedIn() &&
        resource.data.courseId == request.resource.data.courseId &&
        canEditCourseResource(resource.data.courseId) &&
        isValidTopic(request.resource.data);

      allow delete: if isSignedIn() &&
        canEditCourseResource(resource.data.courseId);
    }

    /* ---------- Wallets / Ledger (read-only to clients) ---------- */
    match /wallets/{walletId} {
      allow get, list: if isSignedIn() && (
        targetNotExists() ||
        (
          resource.data.ownerType == "user" &&
          resource.data.ownerId == request.auth.uid
        ) ||
        (
          resource.data.ownerType == "host" &&
          resource.data.ownerId is string &&
          canEditCourseResource(resource.data.ownerId)
        )
      );

      // Wallet creation/updates are server-side only.
      allow create, update, delete: if false;

      match /entries/{entryId} {
        allow get, list: if isSignedIn() && (
          exists(/databases/$(database)/documents/wallets/$(walletId)) &&
          (
            (
              get(/databases/$(database)/documents/wallets/$(walletId)).data.ownerType == "user" &&
              get(/databases/$(database)/documents/wallets/$(walletId)).data.ownerId == request.auth.uid
            ) ||
            (
              get(/databases/$(database)/documents/wallets/$(walletId)).data.ownerType == "host" &&
              get(/databases/$(database)/documents/wallets/$(walletId)).data.ownerId is string &&
              canEditCourseResource(get(/databases/$(database)/documents/wallets/$(walletId)).data.ownerId)
            )
          )
        );
        // Ledger writes are server-side only.
        allow create, update, delete: if false;
      }
    }

    /* ---------- Course Roster ---------- */
    match /courses/{courseId}/roster/{memberId} {
      // Members can read their own roster entry
      allow get: if isSignedIn() && (
        memberId == request.auth.uid ||
        isCourseMember(courseId)
      );

      // Members can list the entire roster if they are a member
      allow list: if isSignedIn() && isCourseMember(courseId);

      // Only instructor (or owner) can invite / change roles / remove
      allow create, update: if isSignedIn() && (
        // allow if the course doc is not exists (initial setup)
        !exists(/databases/$(database)/documents/courses/$(courseId)) ||
        isInstructorOfCourse(courseId) ||
        isOwnerOfCourse(courseId)
      ) && isValidRosterEntry(request.resource.data);
      allow delete: if isSignedIn() && (
        isInstructorOfCourse(courseId) ||
        isOwnerOfCourse(courseId)
      );
    }

    /* ---------- Assignments (top-level) ---------- */
    match /assignments/{aid} {
      allow get: if isSignedIn() && (
        targetNotExists() || // allow reading non-existent docs
        // standalone: visible to creator (check createdBy first)
        ('createdBy' in resource.data && resource.data.createdBy == request.auth.uid &&
         (!('courseId' in resource.data) || resource.data.courseId == null)) ||
        // course-bound assignments: visible to course members
        ('courseId' in resource.data && resource.data.courseId != null && isCourseMember(resource.data.courseId))
      );

      allow list: if isSignedIn() && (
        targetNotExists() || // allow listing empty collection
        // standalone: visible to creator (check createdBy first)
        ('createdBy' in resource.data && resource.data.createdBy == request.auth.uid && 
         (!('courseId' in resource.data) || resource.data.courseId == null)) ||
        // course-bound assignments: visible to course members
        ('courseId' in resource.data && resource.data.courseId != null && isCourseMember(resource.data.courseId))
      );

      // Create/update by course instructors/TAs or assignment creator for standalone
      allow create: if isSignedIn() && (
        (request.resource.data.courseId != null &&
           (canEditCourseResource(request.resource.data.courseId))) ||
        (request.resource.data.courseId == null && request.resource.data.createdBy == request.auth.uid)
      ) && isValidAssignment(request.resource.data);

      allow update: if isSignedIn() && (
        (resource.data.courseId != null &&
           (canEditCourseResource(resource.data.courseId))) ||
        (resource.data.courseId == null && resource.data.createdBy == request.auth.uid)
      ) && isValidAssignment(request.resource.data);

      allow delete: if isSignedIn() && (
        (resource.data.courseId != null &&
           (canEditCourseResource(resource.data.courseId))) ||
        (resource.data.courseId == null && resource.data.createdBy == request.auth.uid)
      );

      /* ------ Submissions subcollection ------ */
      match /submissions/{userId} {
        // GET:
        // - The student may read their own submission
        // - Instructors/TAs of the course may read all
        allow get: if isSignedIn() && (
          userId == request.auth.uid ||
          (get(/databases/$(database)/documents/assignments/$(aid)).data.courseId != null &&
           canEditCourseResource(get(/databases/$(database)/documents/assignments/$(aid)).data.courseId))
        );

        // LIST:
        // - Instructors/TAs can list all submissions
        // - Students cannot list (can only get their own)
        allow list: if isSignedIn() && (
          get(/databases/$(database)/documents/assignments/$(aid)).data.courseId != null &&
          canEditCourseResource(get(/databases/$(database)/documents/assignments/$(aid)).data.courseId)
        );

        // CREATE by the student (their own doc id == uid)
        allow create: if isSignedIn() && 
          userId == request.auth.uid &&
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.state == "in_progress" &&
          isValidSubmission(request.resource.data);
        
        // UPDATE by the student or instructor/TA
        allow update: if isSignedIn() && isValidSubmission(request.resource.data) && (
          // Student can edit their own while in progress or submit
          (userId == request.auth.uid &&
           request.resource.data.userId == request.auth.uid &&
           // Students cannot modify grading fields
           request.resource.data.scoreCompletion == resource.data.scoreCompletion &&
           request.resource.data.notes == resource.data.notes &&
           (
             (resource.data.state == "in_progress" && 
              request.resource.data.state in ["in_progress", "submitted"]) ||
             (resource.data.state == "submitted" && 
              (
                // Allow resubmission only if assignment allows it
                (request.resource.data.state == "in_progress" &&
                 assignmentDoc(aid).data.allowResubmit == true) ||
                // Otherwise only allow no-op state edits
                (request.resource.data.state == "submitted")
              )) ||
             (resource.data.state == "graded_complete" &&
              request.resource.data.state == "in_progress" &&
              assignmentDoc(aid).data.allowResubmit == true)
           )) ||

          // Instructor/TA can grade (move to graded_complete, set notes/score)
          (get(/databases/$(database)/documents/assignments/$(aid)).data.courseId != null &&
           canEditCourseResource(get(/databases/$(database)/documents/assignments/$(aid)).data.courseId))
        );

        // Prevent deletion by students; allow for instructors if you really need it
        allow delete: if isSignedIn() && (
          get(/databases/$(database)/documents/assignments/$(aid)).data.courseId != null &&
          isInstructorOfCourse(get(/databases/$(database)/documents/assignments/$(aid)).data.courseId)
        );
      }
    }

    /* ---------- Conversations (top-level) ---------- */
    match /conversations/{cid} {
      // GET:
      // - Owner (student)
      // - Instructors/TAs of linked assignment course
      allow get: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        (
          // Safely read assignment to resolve course
          exists(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)) &&
          canEditCourseResource(get(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)).data.courseId)
        )
      );

      // LIST:
      // - Owner (student) can list their own conversations
      // - Instructors/TAs of linked assignment course can list
      allow list: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        (
          // Safely read assignment to resolve course
          exists(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)) &&
          canEditCourseResource(get(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)).data.courseId)
        )
      );

      // CREATE: student creates their own conversation only
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid &&
        isValidConversation(request.resource.data);

      // UPDATE:
      // - Student can append turns / move through allowed states
      // - Instructors/TAs can move to closed
      // - If the last turn's pendingStartAt is not null, updates are denied
      allow update: if isSignedIn() &&
        isValidConversation(request.resource.data) &&
        (
          // Disallow update if last turn's pendingStartAt is not null
          (resource.data.turns.size() == 0 || resource.data.turns[resource.data.turns.size() - 1].pendingStartAt == null)
        ) && (
          request.auth.uid == resource.data.userId ||
          (
            exists(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)) &&
            canEditCourseResource(get(/databases/$(database)/documents/assignments/$(resource.data.assignmentId)).data.courseId)
          )
        );

      // DELETE: typically disallow
      allow delete: if false;
    }

    /* ---------- Questionnaires (top-level) ---------- */
    match /questionnaires/{qid} {
      // GET:
      // - Standalone questionnaires: visible to creator
      // - Course-bound questionnaires: visible to course members
      allow get: if isSignedIn() && (
        targetNotExists() ||
        // standalone: visible to creator
        ('createdBy' in resource.data && resource.data.createdBy == request.auth.uid &&
         (!('courseId' in resource.data) || resource.data.courseId == null)) ||
        // course-bound: visible to course members
        ('courseId' in resource.data && resource.data.courseId != null && isCourseMember(resource.data.courseId))
      );

      // LIST:
      // - Standalone questionnaires: visible to creator
      // - Course-bound questionnaires: visible to course members
      allow list: if isSignedIn() && (
        targetNotExists() ||
        // standalone: visible to creator
        ('createdBy' in resource.data && resource.data.createdBy == request.auth.uid &&
         (!('courseId' in resource.data) || resource.data.courseId == null)) ||
        // course-bound: visible to course members
        ('courseId' in resource.data && resource.data.courseId != null && isCourseMember(resource.data.courseId))
      );

      // CREATE: by course instructors/TAs or creator for standalone
      allow create: if isSignedIn() && (
        (request.resource.data.courseId != null &&
           canEditCourseResource(request.resource.data.courseId)) ||
        (request.resource.data.courseId == null && request.resource.data.createdBy == request.auth.uid)
      ) && isValidQuestionnaire(request.resource.data);

      // UPDATE: by course instructors/TAs or creator for standalone
      allow update: if isSignedIn() &&
        // Prevent privilege escalation by making ownership/binding immutable
        request.resource.data.courseId == resource.data.courseId &&
        request.resource.data.createdBy == resource.data.createdBy &&
        (
          (resource.data.courseId != null &&
             canEditCourseResource(resource.data.courseId)) ||
          (resource.data.courseId == null && resource.data.createdBy == request.auth.uid)
        ) && isValidQuestionnaire(request.resource.data);

      // DELETE: by course instructors/TAs or creator for standalone
      allow delete: if isSignedIn() && (
        (resource.data.courseId != null &&
           canEditCourseResource(resource.data.courseId)) ||
        (resource.data.courseId == null && resource.data.createdBy == request.auth.uid)
      );
    }

    /* ---------- QuestionnaireResponses (top-level) ---------- */
    match /questionnaireResponses/{rid} {
      // GET:
      // - Student can read their own response
      // - Instructors/TAs can read responses for questionnaires in their course
      allow get: if isSignedIn() && (
        targetNotExists() ||
        request.auth.uid == resource.data.userId ||
        (
          // Verify courseId matches the questionnaire's courseId and user can edit that course
          resource.data.courseId != null &&
          exists(/databases/$(database)/documents/questionnaires/$(resource.data.questionnaireId)) &&
          resource.data.courseId == questionnaireDoc(resource.data.questionnaireId).data.courseId &&
          canEditCourseResource(resource.data.courseId)
        )
      );

      // LIST:
      // - Student can list their own responses
      // - Instructors/TAs can list responses for questionnaires in their course
      allow list: if isSignedIn() && (
        targetNotExists() ||
        (resource.data != null && (
          ('userId' in resource.data && request.auth.uid == resource.data.userId) ||
          (
            // Verify courseId matches the questionnaire's courseId and user can edit that course
            'courseId' in resource.data &&
            resource.data.courseId != null &&
            exists(/databases/$(database)/documents/questionnaires/$(resource.data.questionnaireId)) &&
            resource.data.courseId == questionnaireDoc(resource.data.questionnaireId).data.courseId &&
            canEditCourseResource(resource.data.courseId)
          )
        ))
      );

      // CREATE: student creates their own response only
      // Verify courseId matches the questionnaire's courseId
      allow create: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid &&
        isValidQuestionnaireResponse(request.resource.data) &&
        exists(/databases/$(database)/documents/questionnaires/$(request.resource.data.questionnaireId)) &&
        (
          // Either both are null (standalone) or courseId must match questionnaire's courseId
          (request.resource.data.courseId == null &&
           questionnaireDoc(request.resource.data.questionnaireId).data.courseId == null) ||
          (request.resource.data.courseId != null &&
           request.resource.data.courseId == questionnaireDoc(request.resource.data.questionnaireId).data.courseId)
        );

      // UPDATE: student can update their own response only
      // Cannot change userId, questionnaireId, or courseId
      allow update: if isSignedIn() &&
        request.auth.uid == resource.data.userId &&
        request.resource.data.userId == resource.data.userId &&
        request.resource.data.questionnaireId == resource.data.questionnaireId &&
        request.resource.data.courseId == resource.data.courseId &&
        exists(/databases/$(database)/documents/questionnaires/$(resource.data.questionnaireId)) &&
        request.resource.data.courseId == questionnaireDoc(resource.data.questionnaireId).data.courseId &&
        isValidQuestionnaireResponse(request.resource.data);

      // DELETE:
      // - Students cannot delete
      // - Instructors/TAs can delete responses in their course
      allow delete: if isSignedIn() &&
        resource.data != null &&
        resource.data.courseId != null &&
        exists(/databases/$(database)/documents/questionnaires/$(resource.data.questionnaireId)) &&
        resource.data.courseId == questionnaireDoc(resource.data.questionnaireId).data.courseId &&
        canEditCourseResource(resource.data.courseId);
    }

    /* ---------- Collection Group Rules ---------- */
    
    // Roster collection group - allows users to query their own roster entries across all courses
    match /{path=**}/roster/{memberId} {
      // Users can only query their own roster entries across all courses
      // This supports listMyEnrolledCourses API which queries: 
      // collectionGroup("roster").where("userId", "==", currentUser.uid).where("status", "==", "active")
      allow read: if isSignedIn() && 
        resource.data != null &&
        'userId' in resource.data &&
        resource.data.userId == request.auth.uid;
    }

    /* ---------- Fallback ---------- */
    match /{document=**} {
      // Fallback deny
      allow get, list: if false;
      allow create, update, delete: if false;
    }
  }
}
