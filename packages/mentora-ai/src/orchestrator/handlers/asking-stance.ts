/**
 * Stage 1: Asking Stance Handler
 */
import { INITIAL_CONFIDENCE } from "../../builder/schemas.js";
import {
    askingStanceBuilders,
    type AskingStanceClassifier,
    type AskingStanceResponse,
} from "../../builder/stage1-asking-stance.js";
import {
    caseChallengeBuilders,
    type CaseChallengeResponse,
} from "../../builder/stage2-case-challenge.js";
import { DialogueStage } from "../../builder/types.js";
import { formatStageResponse } from "../format.js";
import { createStanceVersion, transitionTo } from "../state.js";
import type { StageContext, StageHandler, StageResult } from "../types.js";

/**
 * Handler for Stage 1: Asking Stance
 *
 * Responsibilities:
 * - Analyze student responses for clear stance
 * - Re-ask when responses are ambiguous (TR_CLARIFY)
 * - Transition to Stage 2 when stance is confirmed (TR_V1_ESTABLISHED)
 */
export class AskingStanceHandler implements StageHandler {
    readonly stage = DialogueStage.ASKING_STANCE;

    async handle(context: StageContext): Promise<StageResult> {
        const { executor, state, studentMessage } = context;

        // Step 1: Classify user input using Classifier
        const classifierPrompt = await askingStanceBuilders.classifier.build(
            state.conversationHistory,
            {
                currentQuestion: state.topic,
                userInput: studentMessage,
            },
        );

        const classification = (await executor.execute(
            classifierPrompt,
        )) as AskingStanceClassifier;

        // Step 2: Route based on detected intent
        if (classification.detected_intent === "TR_CLARIFY") {
            return this.handleClarify(context);
        }

        return this.handleConfirmStance(context, classification);
    }

    /**
     * Handle clarification when stance is unclear (TR_CLARIFY)
     * Uses the initial builder to re-ask the question
     */
    private async handleClarify(context: StageContext): Promise<StageResult> {
        const { executor, state } = context;

        const clarifyPrompt = await askingStanceBuilders.initial.build(
            state.conversationHistory,
            {
                topic: state.topic,
            },
        );

        const response = (await executor.execute(
            clarifyPrompt,
        )) as AskingStanceResponse;

        const message = formatStageResponse(response);

        return {
            message,
            newState: transitionTo(state, DialogueStage.ASKING_STANCE),
            ended: false,
            usage: executor.getTokenUsage(),
        };
    }

    /**
     * Handle confirmed stance - create V1 and transition to Stage 2 (TR_V1_ESTABLISHED)
     */
    private async handleConfirmStance(
        context: StageContext,
        classification: AskingStanceClassifier,
    ): Promise<StageResult> {
        const { executor, state, studentMessage } = context;

        // Extract stance from classifier output
        const extractedStance =
            classification.extracted_data?.stance || studentMessage;
        const extractedReason = classification.extracted_data?.reasoning || "";

        // Create initial stance (V1)
        const stance = createStanceVersion(
            extractedStance,
            extractedReason,
            1,
            INITIAL_CONFIDENCE,
        );

        // Generate first case challenge (Stage 2 entry)
        const casePrompt = await caseChallengeBuilders.challenge.build(
            state.conversationHistory,
            {
                currentStance: stance.position,
                caseContent: "", // Will be generated by the model
            },
        );

        const response = (await executor.execute(
            casePrompt,
        )) as CaseChallengeResponse;

        const message = formatStageResponse(response);

        const newState = {
            ...transitionTo(state, DialogueStage.CASE_CHALLENGE),
            currentStance: stance,
            stanceHistory: [stance],
            loopCount: 0,
        };

        return {
            message,
            newState,
            ended: false,
            usage: executor.getTokenUsage(),
        };
    }
}
