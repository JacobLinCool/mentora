/**
 * Stage 2: Case Challenge Handler
 */
import {
    caseChallengeBuilders,
    type CaseChallengeClassifier,
    type CaseChallengeResponse,
} from "../../builder/stage2-case-challenge.js";
import {
    principleReasoningBuilders,
    type PrincipleReasoningResponse,
} from "../../builder/stage3-principle-reasoning.js";
import { DialogueStage } from "../../builder/types.js";
import { formatStageResponse } from "../format.js";
import { formatStanceHistory, transitionTo, updateStance } from "../state.js";
import type { StageContext, StageHandler, StageResult } from "../types.js";

/**
 * Handler for Stage 2: Case Challenge
 *
 * Responsibilities:
 * - Analyze student responses for stance changes
 * - Scaffold when stance wavers (TR_SCAFFOLD)
 * - Re-ask when unclear (TR_CLARIFY)
 * - Transition to Stage 3 when ready for principle reasoning (TR_CASE_COMPLETED)
 */
export class CaseChallengeHandler implements StageHandler {
    readonly stage = DialogueStage.CASE_CHALLENGE;

    async handle(context: StageContext): Promise<StageResult> {
        const { executor, state, studentMessage } = context;
        const currentStance = state.currentStance!;

        // Get the last case challenge (from model's previous message)
        const lastModelMessage =
            state.conversationHistory
                .slice()
                .reverse()
                .find((msg) => msg.role === "model")?.parts?.[0]?.text || "";

        // Step 1: Classify user input using Classifier
        const classifierPrompt = await caseChallengeBuilders.classifier.build(
            state.conversationHistory,
            {
                previousStance: `${currentStance.position} (理由: ${currentStance.reason})`,
                currentCase: lastModelMessage,
                userInput: studentMessage,
            },
        );

        const classification = (await executor.execute(
            classifierPrompt,
        )) as CaseChallengeClassifier;

        // Step 2: Route based on detected intent
        switch (classification.detected_intent) {
            case "TR_CLARIFY":
                return this.handleClarify(context);

            case "TR_SCAFFOLD":
                return this.handleScaffold(context, classification);

            case "TR_CASE_COMPLETED":
                return this.handleCaseCompleted(context);
        }
    }

    /**
     * Handle clarification for unclear response (TR_CLARIFY)
     * Re-presents the case challenge
     */
    private async handleClarify(context: StageContext): Promise<StageResult> {
        const { executor, state } = context;
        const currentStance = state.currentStance!;

        // Re-ask with the challenge builder
        const clarifyPrompt = await caseChallengeBuilders.challenge.build(
            state.conversationHistory,
            {
                currentStance: currentStance.position,
                caseContent: "", // Will be generated by the model
            },
        );

        const response = (await executor.execute(
            clarifyPrompt,
        )) as CaseChallengeResponse;

        const message = formatStageResponse(response);

        return {
            message,
            newState: transitionTo(state, DialogueStage.CASE_CHALLENGE),
            ended: false,
            usage: executor.getTokenUsage(),
        };
    }

    /**
     * Handle scaffolding when stance wavers (TR_SCAFFOLD)
     * This prompts the student to update their stance
     */
    private async handleScaffold(
        context: StageContext,
        classification: CaseChallengeClassifier,
    ): Promise<StageResult> {
        const { executor, state, studentMessage } = context;
        const currentStance = state.currentStance!;

        const scaffoldPrompt = await caseChallengeBuilders.scaffold.build(
            state.conversationHistory,
            {
                userInput: studentMessage,
                currentStance: currentStance.position,
            },
        );

        const response = (await executor.execute(
            scaffoldPrompt,
        )) as CaseChallengeResponse;

        const message = formatStageResponse(response);

        // Update stance if new stance was extracted
        let newState = transitionTo(state, DialogueStage.CASE_CHALLENGE);
        if (classification.extracted_data?.stance) {
            newState = updateStance(
                newState,
                classification.extracted_data.stance,
                classification.extracted_data.reasoning || "",
                classification.confidence_score,
            );
        }

        return {
            message,
            newState,
            ended: false,
            usage: executor.getTokenUsage(),
        };
    }

    /**
     * Handle case completed - advance to principle reasoning (TR_CASE_COMPLETED)
     */
    private async handleCaseCompleted(
        context: StageContext,
    ): Promise<StageResult> {
        const { executor, state } = context;

        // Generate discussion summary for principle reasoning
        const discussionSummary = formatStanceHistory(state.stanceHistory);

        // Move to Stage 3: Principle Reasoning
        const principlePrompt =
            await principleReasoningBuilders.reasoning.build(
                state.conversationHistory,
                {
                    discussionSummary,
                },
            );

        const response = (await executor.execute(
            principlePrompt,
        )) as PrincipleReasoningResponse;

        const message = formatStageResponse(response);

        return {
            message,
            newState: {
                ...transitionTo(state, DialogueStage.PRINCIPLE_REASONING),
                loopCount: state.loopCount + 1,
            },
            ended: false,
            usage: executor.getTokenUsage(),
        };
    }
}
